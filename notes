Integration of cvc4 currently works as follow:

* Before CVC4:
** the reduction relation relied on δ for mapping primitive applications to answers
** δ in turns relied on the provability relation (σ ⊢ V : C : (Proved|Neither|Refuted))
for answers on primitive predicates.
This provability relation was also used in the contract monitoring rule.

* We integrate CVC4 by extending the old provability relation
when it returns "Neither" and the contract C is of a form
we know how to translate.
At this time this is limited to contracts on arithmetic relations.
(Complex contracts we cannot translate/prove right away will
eventually go through evaluation,
which will then query the prover using a small number
of well-understood contract forms.
So like before, we can cope with a large range of obfuscation.)

* Each pair <V,C> can be translated to a query in CVC4.
For example, we translate <L0, λx.(x>L1)> to "L0 > L1"

* For a provability relation (σ ⊢ V : C):
** The store σ gives all neccessary information for generating premises.
But instead of scanning the entire store,
we start with labels in V and C then expand from that.
Let P be the premises.
** Translating the pair <V,C> gives the statement we want to check. Let it be Q.
** If (P ⇒ Q) is valid (or (P ∧ ¬Q) unsat, i don't know which is better), (σ ⊢ V : C : Proved)
   If (P ∧ Q) is unsat, (σ ⊢ V : C : Refuted)
   Otherwise we return "Neither" as a safe answer.

* Efficiency concern:
The first few queries always give "Neither" because we don't have enough information.
It turns out many of them look like this:
    L0,L1: REAL;
    QUERY L0 > L1;
As a cheap way of mitigating useless queries,
we don't call CVC4 when there's no premise
and rely on our previous lo-tech solver to be precise enough
not to miss trivial cases like "L1=L1".


TODO:

* intros 1 2 3, dvh 1 2 3, sum, max, mc91, hors can now be verified but with longer run-time (still under 1s)
* mult won't be easily solved because the contract is at "sqr" while the invariant should have been maintained at "mult".
Simply adding (>=/c 0) to mult's range makes the verification go through though.
